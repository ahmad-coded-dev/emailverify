<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <title>Terms & Conditions</title>
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <link rel="stylesheet" href="./sass/index.scss" />
        <link
            href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600;700&display=swap"
            rel="stylesheet"
        />
        <link rel="icon" href="./images/favicon.ico" />
    </head>
    <body>
        <div class="bg_for_body"></div>
        <!-- main page background mask -->
        <img class="main_bg_absolute" src="./images/mask.svg" />

        <button class="mob_navbar_hamburger">
            <img class="mob_navbar_hamburger" src="./images/hamburger.svg" />
        </button>

        <!-- navbar  -->
        <a class="mob_navbar_logo" href="./index.html"
            ><img src="./images/emailverify_logo.svg"
        /></a>
        <div class="main-navbar" id="navbarr">
            <div class="navbar hide_navbar">
                <div class="navbar_logo">
                    <a href="./index.html"
                        ><img src="./images/emailverify_logo.svg"
                    /></a>
                </div>
                <button class="mob_navbar_cross">
                    <img class="mob_navbar_cross" src="./images/cross.svg" />
                </button>
                <div class="navbar_links_buttons">
                    <div class="links_for_mobile_navbar">
                        <a href="#" class="login_btn">Login</a>
                        <a href="#" class="signup_btn">Sign up</a>
                        <a href="#" class="dashboard_btn">Dashboard</a>
                    </div>
                    <div class="navbar_links">
                        <div class="menuitems">
                            <a href="./index.html">Home</a>
                        </div>
                        <div class="menuitems">
                            <a href="./pricing.html">Pricing</a>
                        </div>
                        <div class="menuitems">
                            <a href="./about.html">About us</a>
                        </div>
                    </div>

                    <div class="navbar_buttons">
                        <a href="#" class="login_btn">Login</a>
                        <a href="#" class="signup_btn">Sign up</a>
                        <a href="#" class="dashboard_btn">Dashboard</a>
                    </div>
                </div>
            </div>
        </div>

        <!-- terms & Conditions -->

        <div class="terms_desc">
            <h1><span> Terms & </span>Conditions</h1>
            <p>Last updated: <span>6 Apr 2022</span></p>
        </div>

        <div class="terms_conditions">
            <h1>Lorem ipsum</h1>
            <p>
                One of the most important parameters in deciding a parsing
                strategy is how the input is received; is it one buffer that
                contains the entirety of the structure, or a partial buffer (a
                chunk) that gets more data over time (streaming)?
                <br /><br />
                When dealing with the entirety of the structure in a single
                buffer at once, the algorithm is usually very simple to express.
                You can have a simple loop that goes from start to finish in the
                buffer, and keep state and context data relevant to the problem
                updated as the loop proceeds. There is usually never a reason to
                backtrack in the buffer itself, since out-of-band state and
                context data should be correctly kept up-to-date regarding
                what’s been parsed so far.
                <br /><br />
                When dealing with only chunks of the structure at a time, where
                chunk boundaries may occur at arbitrary points in the structure,
                parsing becomes significantly more difficult because the control
                flow is harder to express; a simple loop is usually never
                sufficient. However, by asking certain questions and coming up
                with the right solutions for your particular problem, the parse
                can be made a lot simpler:
            </p>

            <h3>What is the input source?</h3>
            <p>
                Is the input going to be retrieved in one big chunk, or in
                multiple fixed-sized chunks, or in multiple variable-sized
                chunks? And is the chunk size going to be sufficient for
                performing all parse steps, or will we need to buffer previous
                chunks until we get 1 bigger chunk that can be properly parsed?
                <br />
                What non-buffer data (i.e. context/state) is needed to help
                perform a later parse step given the current chunk?
                <br />
                How is the data encoded inside the buffer going to be output to
                the user after parsing?
                <br />
                What guarantees do we have about total size? Do we know in
                advance, or do we need to track how much has been input so far,
                in order to enforce limits?
            </p>

            <h1>Lorem ipsum</h1>
            <p>
                One of the most important parameters in deciding a parsing
                strategy is how the input is received; is it one buffer that
                contains the entirety of the structure, or a partial buffer (a
                chunk) that gets more data over time (streaming)?
                <br /><br />
                When dealing with the entirety of the structure in a single
                buffer at once, the algorithm is usually very simple to express.
                You can have a simple loop that goes from start to finish in the
                buffer, and keep state and context data relevant to the problem
                updated as the loop proceeds. There is usually never a reason to
                backtrack in the buffer itself, since out-of-band state and
                context data should be correctly kept up-to-date regarding
                what’s been parsed so far.
                <br /><br />
                When dealing with only chunks of the structure at a time, where
                chunk boundaries may occur at arbitrary points in the structure,
                parsing becomes significantly more difficult because the control
                flow is harder to express; a simple loop is usually never
                sufficient. However, by asking certain questions and coming up
                with the right solutions for your particular problem, the parse
                can be made a lot simpler:
            </p>

            <h3>What is the input source?</h3>
            <p>
                Is the input going to be retrieved in one big chunk, or in
                multiple fixed-sized chunks, or in multiple variable-sized
                chunks? And is the chunk size going to be sufficient for
                performing all parse steps, or will we need to buffer previous
                chunks until we get 1 bigger chunk that can be properly parsed?
                <br />
                What non-buffer data (i.e. context/state) is needed to help
                perform a later parse step given the current chunk?
                <br />
                How is the data encoded inside the buffer going to be output to
                the user after parsing?
                <br />
                What guarantees do we have about total size? Do we know in
                advance, or do we need to track how much has been input so far,
                in order to enforce limits?
            </p>
        </div>

        <the-footer></the-footer>

        <script type="module" src="./js/check_cookie.js"></script>
        <script src="./js/nav.js"></script>
        <script type="module" src="./js/components.js"></script>
    </body>
</html>
